{"ast":null,"code":"import{mergeAll}from'../operators/mergeAll';import{innerFrom}from'./innerFrom';import{EMPTY}from'./empty';import{popNumber,popScheduler}from'../util/args';import{from}from'./from';export function merge(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}var scheduler=popScheduler(args);var concurrent=popNumber(args,Infinity);var sources=args;return!sources.length?EMPTY:sources.length===1?innerFrom(sources[0]):mergeAll(concurrent)(from(sources,scheduler));}","map":{"version":3,"names":["mergeAll","innerFrom","EMPTY","popNumber","popScheduler","from","merge","args","_i","arguments","length","scheduler","concurrent","Infinity","sources"],"sources":["/Users/jawaadahmar/Desktop/atlas-clothing/client/src/thistle-lion/node_modules/rxjs/src/internal/observable/merge.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\nimport { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\n): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\n): Observable<A[number]>;\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Merge together two Observables: 1s interval and clicks\n *\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * Merge together 3 Observables, but run only 2 concurrently\n *\n * ```ts\n * import { interval, take, merge } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits its max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits its max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n */\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  const sources = args as ObservableInput<unknown>[];\n  return !sources.length\n    ? // No source provided\n      EMPTY\n    : sources.length === 1\n    ? // One source? Just return it.\n      innerFrom(sources[0])\n    : // Merge all sources\n      mergeAll(concurrent)(from(sources, scheduler));\n}\n"],"mappings":"AAEA,OAASA,QAAQ,KAAQ,uBAAuB,CAChD,OAASC,SAAS,KAAQ,aAAa,CACvC,OAASC,KAAK,KAAQ,SAAS,CAC/B,OAASC,SAAS,CAAEC,YAAY,KAAQ,cAAc,CACtD,OAASC,IAAI,KAAQ,QAAQ,CAmF7B,MAAM,SAAU,CAAAC,KAAKA,CAAA,EAAC,IAAAC,IAAA,I,IAAA,IAAAC,EAAA,EAA8D,CAA9DA,EAAA,CAAAC,SAAA,CAAAC,MAA8D,CAA9DF,EAAA,EAA8D,EAA9DD,IAAA,CAAAC,EAAA,EAAAC,SAAA,CAAAD,EAAA,E,CACpB,GAAM,CAAAG,SAAS,CAAGP,YAAY,CAACG,IAAI,CAAC,CACpC,GAAM,CAAAK,UAAU,CAAGT,SAAS,CAACI,IAAI,CAAEM,QAAQ,CAAC,CAC5C,GAAM,CAAAC,OAAO,CAAGP,IAAkC,CAClD,MAAO,CAACO,OAAO,CAACJ,MAAM,CAElBR,KAAK,CACLY,OAAO,CAACJ,MAAM,GAAK,CAAC,CAEpBT,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC,CAAC,CAErBd,QAAQ,CAACY,UAAU,CAAC,CAACP,IAAI,CAACS,OAAO,CAAEH,SAAS,CAAC,CAAC,CACpD"},"metadata":{},"sourceType":"module","externalDependencies":[]}