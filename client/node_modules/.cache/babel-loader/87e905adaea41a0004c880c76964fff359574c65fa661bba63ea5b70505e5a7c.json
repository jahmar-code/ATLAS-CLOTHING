{"ast":null,"code":"import{Observable}from'../Observable';import{innerFrom}from'../observable/innerFrom';import{Subject}from'../Subject';import{operate}from'../util/lift';import{createOperatorSubscriber,OperatorSubscriber}from'./OperatorSubscriber';export function groupBy(keySelector,elementOrOptions,duration,connector){return operate(function(source,subscriber){var element;if(!elementOrOptions||typeof elementOrOptions==='function'){element=elementOrOptions;}else{duration=elementOrOptions.duration,element=elementOrOptions.element,connector=elementOrOptions.connector;}var groups=new Map();var notify=function notify(cb){groups.forEach(cb);cb(subscriber);};var handleError=function handleError(err){return notify(function(consumer){return consumer.error(err);});};var activeGroups=0;var teardownAttempted=false;var groupBySourceSubscriber=new OperatorSubscriber(subscriber,function(value){try{var key_1=keySelector(value);var group_1=groups.get(key_1);if(!group_1){groups.set(key_1,group_1=connector?connector():new Subject());var grouped=createGroupedObservable(key_1,group_1);subscriber.next(grouped);if(duration){var durationSubscriber_1=createOperatorSubscriber(group_1,function(){group_1.complete();durationSubscriber_1===null||durationSubscriber_1===void 0?void 0:durationSubscriber_1.unsubscribe();},undefined,undefined,function(){return groups.delete(key_1);});groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));}}group_1.next(element?element(value):value);}catch(err){handleError(err);}},function(){return notify(function(consumer){return consumer.complete();});},handleError,function(){return groups.clear();},function(){teardownAttempted=true;return activeGroups===0;});source.subscribe(groupBySourceSubscriber);function createGroupedObservable(key,groupSubject){var result=new Observable(function(groupSubscriber){activeGroups++;var innerSub=groupSubject.subscribe(groupSubscriber);return function(){innerSub.unsubscribe();--activeGroups===0&&teardownAttempted&&groupBySourceSubscriber.unsubscribe();};});result.key=key;return result;}});}","map":{"version":3,"names":["Observable","innerFrom","Subject","operate","createOperatorSubscriber","OperatorSubscriber","groupBy","keySelector","elementOrOptions","duration","connector","source","subscriber","element","groups","Map","notify","cb","forEach","handleError","err","consumer","error","activeGroups","teardownAttempted","groupBySourceSubscriber","value","key_1","group_1","get","set","grouped","createGroupedObservable","next","durationSubscriber_1","complete","unsubscribe","undefined","delete","add","subscribe","clear","key","groupSubject","result","groupSubscriber","innerSub"],"sources":["/Users/jawaadahmar/Desktop/atlas-clothing/client/src/thistle-lion/node_modules/rxjs/src/internal/operators/groupBy.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { ObservableInput, Observer, OperatorFunction, SubjectLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\n\nexport interface BasicGroupByOptions<K, T> {\n  element?: undefined;\n  duration?: (grouped: GroupedObservable<K, T>) => ObservableInput<any>;\n  connector?: () => SubjectLike<T>;\n}\n\nexport interface GroupByOptionsWithElement<K, E, T> {\n  element: (value: T) => E;\n  duration?: (grouped: GroupedObservable<K, E>) => ObservableInput<any>;\n  connector?: () => SubjectLike<E>;\n}\n\nexport function groupBy<T, K>(key: (value: T) => K, options: BasicGroupByOptions<K, T>): OperatorFunction<T, GroupedObservable<K, T>>;\n\nexport function groupBy<T, K, E>(\n  key: (value: T) => K,\n  options: GroupByOptionsWithElement<K, E, T>\n): OperatorFunction<T, GroupedObservable<K, E>>;\n\nexport function groupBy<T, K extends T>(\n  key: (value: T) => value is K\n): OperatorFunction<T, GroupedObservable<true, K> | GroupedObservable<false, Exclude<T, K>>>;\n\nexport function groupBy<T, K>(key: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K>(\n  key: (value: T) => K,\n  element: void,\n  duration: (grouped: GroupedObservable<K, T>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * ![](groupBy.png)\n *\n * When the Observable emits an item, a key is computed for this item with the key function.\n *\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Otherwise, a new\n * {@link GroupedObservable} for this key is created and emits.\n *\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\n * key is available as the `key` field of a {@link GroupedObservable} instance.\n *\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\n * returned by the element function.\n *\n * ## Examples\n *\n * Group objects by `id` and return as array\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [])))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // [{ id: 1, name: 'JavaScript' }, { id: 1, name: 'TypeScript'}]\n * // [{ id: 2, name: 'Parcel' }, { id: 2, name: 'webpack'}]\n * // [{ id: 3, name: 'TSLint' }]\n * ```\n *\n * Pivot data on the `id` field\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce, map } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id, { element: p => p.name }),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [`${ group$.key }`]))),\n *   map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\n * // { id: 3, values: [ 'TSLint' ] }\n * ```\n *\n * @param key A function that extracts the key\n * for each item.\n * @param element A function that extracts the\n * return element for each item.\n * @param duration\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @param connector Factory function to create an\n * intermediate Subject through which grouped elements are emitted.\n * @return A function that returns an Observable that emits GroupedObservables,\n * each of which corresponds to a unique key value and each of which emits\n * those items from the source Observable that share that key value.\n *\n * @deprecated Use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n  connector?: () => Subject<R>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n// Impl\nexport function groupBy<T, K, R>(\n  keySelector: (value: T) => K,\n  elementOrOptions?: ((value: any) => any) | void | BasicGroupByOptions<K, T> | GroupByOptionsWithElement<K, R, T>,\n  duration?: (grouped: GroupedObservable<any, any>) => ObservableInput<any>,\n  connector?: () => SubjectLike<any>\n): OperatorFunction<T, GroupedObservable<K, R>> {\n  return operate((source, subscriber) => {\n    let element: ((value: any) => any) | void;\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions as ((value: any) => any);\n    } else {\n      ({ duration, element, connector } = elementOrOptions);\n    }\n\n    // A lookup for the groups that we have so far.\n    const groups = new Map<K, SubjectLike<any>>();\n\n    // Used for notifying all groups and the subscriber in the same way.\n    const notify = (cb: (group: Observer<any>) => void) => {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    // Used to handle errors from the source, AND errors that occur during the\n    // next call from the source.\n    const handleError = (err: any) => notify((consumer) => consumer.error(err));\n\n    // The number of actively subscribed groups\n    let activeGroups = 0;\n\n    // Whether or not teardown was attempted on this subscription.\n    let teardownAttempted = false;\n\n    // Capturing a reference to this, because we need a handle to it\n    // in `createGroupedObservable` below. This is what we use to\n    // subscribe to our source observable. This sometimes needs to be unsubscribed\n    // out-of-band with our `subscriber` which is the downstream subscriber, or destination,\n    // in cases where a user unsubscribes from the main resulting subscription, but\n    // still has groups from this subscription subscribed and would expect values from it\n    // Consider:  `source.pipe(groupBy(fn), take(2))`.\n    const groupBySourceSubscriber = new OperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Because we have to notify all groups of any errors that occur in here,\n        // we have to add our own try/catch to ensure that those errors are propagated.\n        // OperatorSubscriber will only send the error to the main subscriber.\n        try {\n          const key = keySelector(value);\n\n          let group = groups.get(key);\n          if (!group) {\n            // Create our group subject\n            groups.set(key, (group = connector ? connector() : new Subject<any>()));\n\n            // Emit the grouped observable. Note that we can't do a simple `asObservable()` here,\n            // because the grouped observable has special semantics around reference counting\n            // to ensure we don't sever our connection to the source prematurely.\n            const grouped = createGroupedObservable(key, group);\n            subscriber.next(grouped);\n\n            if (duration) {\n              const durationSubscriber = createOperatorSubscriber(\n                // Providing the group here ensures that it is disposed of -- via `unsubscribe` --\n                // when the duration subscription is torn down. That is important, because then\n                // if someone holds a handle to the grouped observable and tries to subscribe to it\n                // after the connection to the source has been severed, they will get an\n                // `ObjectUnsubscribedError` and know they can't possibly get any notifications.\n                group as any,\n                () => {\n                  // Our duration notified! We can complete the group.\n                  // The group will be removed from the map in the finalization phase.\n                  group!.complete();\n                  durationSubscriber?.unsubscribe();\n                },\n                // Completions are also sent to the group, but just the group.\n                undefined,\n                // Errors on the duration subscriber are sent to the group\n                // but only the group. They are not sent to the main subscription.\n                undefined,\n                // Finalization: Remove this group from our map.\n                () => groups.delete(key)\n              );\n\n              // Start our duration notifier.\n              groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n            }\n          }\n\n          // Send the value to our group.\n          group.next(element ? element(value) : value);\n        } catch (err) {\n          handleError(err);\n        }\n      },\n      // Source completes.\n      () => notify((consumer) => consumer.complete()),\n      // Error from the source.\n      handleError,\n      // Free up memory.\n      // When the source subscription is _finally_ torn down, release the subjects and keys\n      // in our groups Map, they may be quite large and we don't want to keep them around if we\n      // don't have to.\n      () => groups.clear(),\n      () => {\n        teardownAttempted = true;\n        // We only kill our subscription to the source if we have\n        // no active groups. As stated above, consider this scenario:\n        // source$.pipe(groupBy(fn), take(2)).\n        return activeGroups === 0;\n      }\n    );\n\n    // Subscribe to the source\n    source.subscribe(groupBySourceSubscriber);\n\n    /**\n     * Creates the actual grouped observable returned.\n     * @param key The key of the group\n     * @param groupSubject The subject that fuels the group\n     */\n    function createGroupedObservable(key: K, groupSubject: SubjectLike<any>) {\n      const result: any = new Observable<T>((groupSubscriber) => {\n        activeGroups++;\n        const innerSub = groupSubject.subscribe(groupSubscriber);\n        return () => {\n          innerSub.unsubscribe();\n          // We can kill the subscription to our source if we now have no more\n          // active groups subscribed, and a finalization was already attempted on\n          // the source.\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}\n\n/**\n * An observable of values that is the emitted by the result of a {@link groupBy} operator,\n * contains a `key` property for the grouping.\n */\nexport interface GroupedObservable<K, T> extends Observable<T> {\n  /**\n   * The key value for the grouped notifications.\n   */\n  readonly key: K;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}