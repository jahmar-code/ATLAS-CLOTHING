{"ast":null,"code":"import{asyncScheduler}from'../scheduler/async';import{operate}from'../util/lift';import{createOperatorSubscriber}from'./OperatorSubscriber';export function debounceTime(dueTime,scheduler){if(scheduler===void 0){scheduler=asyncScheduler;}return operate(function(source,subscriber){var activeTask=null;var lastValue=null;var lastTime=null;var emit=function emit(){if(activeTask){activeTask.unsubscribe();activeTask=null;var value=lastValue;lastValue=null;subscriber.next(value);}};function emitWhenIdle(){var targetTime=lastTime+dueTime;var now=scheduler.now();if(now<targetTime){activeTask=this.schedule(undefined,targetTime-now);subscriber.add(activeTask);return;}emit();}source.subscribe(createOperatorSubscriber(subscriber,function(value){lastValue=value;lastTime=scheduler.now();if(!activeTask){activeTask=scheduler.schedule(emitWhenIdle,dueTime);subscriber.add(activeTask);}},function(){emit();subscriber.complete();},undefined,function(){lastValue=activeTask=null;}));});}","map":{"version":3,"names":["asyncScheduler","operate","createOperatorSubscriber","debounceTime","dueTime","scheduler","source","subscriber","activeTask","lastValue","lastTime","emit","unsubscribe","value","next","emitWhenIdle","targetTime","now","schedule","undefined","add","subscribe","complete"],"sources":["/Users/jawaadahmar/Desktop/atlas-clothing/client/src/thistle-lion/node_modules/rxjs/src/internal/operators/debounceTime.ts"],"sourcesContent":["import { asyncScheduler } from '../scheduler/async';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent notification from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays notifications emitted by the source Observable, but drops\n * previous pending delayed emissions if a new notification arrives on the source\n * Observable. This operator keeps track of the most recent notification from the\n * source Observable, and emits that only when `dueTime` has passed\n * without any other notification appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous notification will be dropped\n * and will not be emitted and a new `dueTime` is scheduled.\n * If the completing event happens during `dueTime` the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during `dueTime` or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * notification to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, debounceTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified `dueTime`, and may drop some values\n * if they occur too frequently.\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let activeTask: Subscription | null = null;\n    let lastValue: T | null = null;\n    let lastTime: number | null = null;\n\n    const emit = () => {\n      if (activeTask) {\n        // We have a value! Free up memory first, then emit the value.\n        activeTask.unsubscribe();\n        activeTask = null;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\n      // This is called `dueTime` after the first value\n      // but we might have received new values during this window!\n\n      const targetTime = lastTime! + dueTime;\n      const now = scheduler.now();\n      if (now < targetTime) {\n        // On that case, re-schedule to the new target\n        activeTask = this.schedule(undefined, targetTime - now);\n        subscriber.add(activeTask);\n        return;\n      }\n\n      emit();\n    }\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          lastValue = value;\n          lastTime = scheduler.now();\n\n          // Only set up a task if it's not already up\n          if (!activeTask) {\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n            subscriber.add(activeTask);\n          }\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = activeTask = null;\n        }\n      )\n    );\n  });\n}\n"],"mappings":"AAAA,OAASA,cAAc,KAAQ,oBAAoB,CAGnD,OAASC,OAAO,KAAQ,cAAc,CACtC,OAASC,wBAAwB,KAAQ,sBAAsB,CA2D/D,MAAM,SAAU,CAAAC,YAAYA,CAAIC,OAAe,CAAEC,SAAyC,EAAzC,GAAAA,SAAA,WAAAA,SAAA,CAAAL,cAAyC,EACxF,MAAO,CAAAC,OAAO,CAAC,SAACK,MAAM,CAAEC,UAAU,EAChC,GAAI,CAAAC,UAAU,CAAwB,IAAI,CAC1C,GAAI,CAAAC,SAAS,CAAa,IAAI,CAC9B,GAAI,CAAAC,QAAQ,CAAkB,IAAI,CAElC,GAAM,CAAAC,IAAI,CAAG,QAAP,CAAAA,IAAIA,CAAA,CAAG,CACX,GAAIH,UAAU,CAAE,CAEdA,UAAU,CAACI,WAAW,EAAE,CACxBJ,UAAU,CAAG,IAAI,CACjB,GAAM,CAAAK,KAAK,CAAGJ,SAAU,CACxBA,SAAS,CAAG,IAAI,CAChBF,UAAU,CAACO,IAAI,CAACD,KAAK,CAAC,C,CAE1B,CAAC,CACD,QAAS,CAAAE,YAAYA,CAAA,EAInB,GAAM,CAAAC,UAAU,CAAGN,QAAS,CAAGN,OAAO,CACtC,GAAM,CAAAa,GAAG,CAAGZ,SAAS,CAACY,GAAG,EAAE,CAC3B,GAAIA,GAAG,CAAGD,UAAU,CAAE,CAEpBR,UAAU,CAAG,IAAI,CAACU,QAAQ,CAACC,SAAS,CAAEH,UAAU,CAAGC,GAAG,CAAC,CACvDV,UAAU,CAACa,GAAG,CAACZ,UAAU,CAAC,CAC1B,O,CAGFG,IAAI,EAAE,CACR,CAEAL,MAAM,CAACe,SAAS,CACdnB,wBAAwB,CACtBK,UAAU,CACV,SAACM,KAAQ,EACPJ,SAAS,CAAGI,KAAK,CACjBH,QAAQ,CAAGL,SAAS,CAACY,GAAG,EAAE,CAG1B,GAAI,CAACT,UAAU,CAAE,CACfA,UAAU,CAAGH,SAAS,CAACa,QAAQ,CAACH,YAAY,CAAEX,OAAO,CAAC,CACtDG,UAAU,CAACa,GAAG,CAACZ,UAAU,CAAC,C,CAE9B,CAAC,CACD,WAGEG,IAAI,EAAE,CACNJ,UAAU,CAACe,QAAQ,EAAE,CACvB,CAAC,CAEDH,SAAS,CACT,WAEEV,SAAS,CAAGD,UAAU,CAAG,IAAI,CAC/B,CAAC,CACF,CACF,CACH,CAAC,CAAC,CACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}