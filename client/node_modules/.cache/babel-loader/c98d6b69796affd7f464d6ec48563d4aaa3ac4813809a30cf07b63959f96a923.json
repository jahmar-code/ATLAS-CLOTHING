{"ast":null,"code":"import{__read}from\"tslib\";import{innerFrom}from'../observable/innerFrom';import{Observable}from'../Observable';import{mergeMap}from'../operators/mergeMap';import{isArrayLike}from'../util/isArrayLike';import{isFunction}from'../util/isFunction';import{mapOneOrManyArgs}from'../util/mapOneOrManyArgs';var nodeEventEmitterMethods=['addListener','removeListener'];var eventTargetMethods=['addEventListener','removeEventListener'];var jqueryMethods=['on','off'];export function fromEvent(target,eventName,options,resultSelector){if(isFunction(options)){resultSelector=options;options=undefined;}if(resultSelector){return fromEvent(target,eventName,options).pipe(mapOneOrManyArgs(resultSelector));}var _a=__read(isEventTarget(target)?eventTargetMethods.map(function(methodName){return function(handler){return target[methodName](eventName,handler,options);};}):isNodeStyleEventEmitter(target)?nodeEventEmitterMethods.map(toCommonHandlerRegistry(target,eventName)):isJQueryStyleEventEmitter(target)?jqueryMethods.map(toCommonHandlerRegistry(target,eventName)):[],2),add=_a[0],remove=_a[1];if(!add){if(isArrayLike(target)){return mergeMap(function(subTarget){return fromEvent(subTarget,eventName,options);})(innerFrom(target));}}if(!add){throw new TypeError('Invalid event target');}return new Observable(function(subscriber){var handler=function handler(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}return subscriber.next(1<args.length?args:args[0]);};add(handler);return function(){return remove(handler);};});}function toCommonHandlerRegistry(target,eventName){return function(methodName){return function(handler){return target[methodName](eventName,handler);};};}function isNodeStyleEventEmitter(target){return isFunction(target.addListener)&&isFunction(target.removeListener);}function isJQueryStyleEventEmitter(target){return isFunction(target.on)&&isFunction(target.off);}function isEventTarget(target){return isFunction(target.addEventListener)&&isFunction(target.removeEventListener);}","map":{"version":3,"names":["innerFrom","Observable","mergeMap","isArrayLike","isFunction","mapOneOrManyArgs","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","target","eventName","options","resultSelector","undefined","pipe","_a","__read","isEventTarget","map","methodName","handler","isNodeStyleEventEmitter","toCommonHandlerRegistry","isJQueryStyleEventEmitter","add","remove","subTarget","TypeError","subscriber","args","_i","arguments","length","next","addListener","removeListener","on","off","addEventListener","removeEventListener"],"sources":["/Users/jawaadahmar/Desktop/atlas-clothing/client/src/thistle-lion/node_modules/rxjs/src/internal/observable/fromEvent.ts"],"sourcesContent":["import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n// These constants are used to create handler registry functions using array mapping below.\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\nconst jqueryMethods = ['on', 'off'] as const;\n\nexport interface NodeStyleEventEmitter {\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\n}\n\n// Use handler types like those in @types/jquery. See:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\nexport interface JQueryStyleEventEmitter<TContext, T> {\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n}\n\nexport interface EventListenerObject<E> {\n  handleEvent(evt: E): void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: EventListenerOptions | boolean\n  ): void;\n}\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  resultSelector: (event: T) => R\n): Observable<R>;\nexport function fromEvent<T>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (event: T) => R\n): Observable<R>;\n\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string\n): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent<T>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string,\n  resultSelector: (value: T, ...args: any[]) => R\n): Observable<R>;\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n *\n * Emit clicks happening on the DOM document\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * Use `addEventListener` with capture option\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * // note optional configuration parameter which will be passed to addEventListener\n * const clicksInDocument = fromEvent(document, 'click', { capture: true });\n * const clicksInDiv = fromEvent(div, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js\n * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n * @param {string} eventName The event name of interest, being emitted by the\n * `target`.\n * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n * @return {Observable<T>}\n */\nexport function fromEvent<T>(\n  target: any,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: (...args: any[]) => T\n): Observable<T> {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  // Figure out our add and remove methods. In order to do this,\n  // we are going to analyze the target in a preferred order, if\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\n  // method names and apply them to a map to create opposite versions of the\n  // same function. This is because they all operate in duplicate pairs,\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\n  // The call only differs by method name, as to whether or not you're adding or removing.\n  const [add, remove] =\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\n    isEventTarget(target)\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\n      : // In all other cases, the call pattern is identical with the exception of the method names.\n      isNodeStyleEventEmitter(target)\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n      : isJQueryStyleEventEmitter(target)\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n      : [];\n\n  // If add is falsy, it's because we didn't match a pattern above.\n  // Check to see if it is an ArrayLike, because if it is, we want to\n  // try to apply fromEvent to all of it's items. We do this check last,\n  // because there are may be some types that are both ArrayLike *and* implement\n  // event registry points, and we'd rather delegate to that when possible.\n  if (!add) {\n    if (isArrayLike(target)) {\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\n        innerFrom(target)\n      ) as Observable<T>;\n    }\n  }\n\n  // If add is falsy and we made it here, it's because we didn't\n  // match any valid target objects above.\n  if (!add) {\n    throw new TypeError('Invalid event target');\n  }\n\n  return new Observable<T>((subscriber) => {\n    // The handler we are going to register. Forwards the event object, by itself, or\n    // an array of arguments to the event handler, if there is more than one argument,\n    // to the consumer.\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\n    // Do the work of adding the handler to the target.\n    add(handler);\n    // When we finalize, we want to remove the handler and free up memory.\n    return () => remove!(handler);\n  });\n}\n\n/**\n * Used to create `add` and `remove` functions to register and unregister event handlers\n * from a target in the most common handler pattern, where there are only two arguments.\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\n * @param target The target we're calling methods on\n * @param eventName The event name for the event we're creating register or unregister functions for\n */\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\n}\n\n/**\n * Checks to see if the target implements the required node-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\n  return isFunction(target.addListener) && isFunction(target.removeListener);\n}\n\n/**\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\n  return isFunction(target.on) && isFunction(target.off);\n}\n\n/**\n * Checks to see if the target implements the required EventTarget methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}