{"ast":null,"code":"import{__read,__spreadArray}from\"tslib\";import{innerFrom}from'../observable/innerFrom';import{Subject}from'../Subject';import{SafeSubscriber}from'../Subscriber';import{operate}from'../util/lift';export function share(options){if(options===void 0){options={};}var _a=options.connector,connector=_a===void 0?function(){return new Subject();}:_a,_b=options.resetOnError,resetOnError=_b===void 0?true:_b,_c=options.resetOnComplete,resetOnComplete=_c===void 0?true:_c,_d=options.resetOnRefCountZero,resetOnRefCountZero=_d===void 0?true:_d;return function(wrapperSource){var connection;var resetConnection;var subject;var refCount=0;var hasCompleted=false;var hasErrored=false;var cancelReset=function cancelReset(){resetConnection===null||resetConnection===void 0?void 0:resetConnection.unsubscribe();resetConnection=undefined;};var reset=function reset(){cancelReset();connection=subject=undefined;hasCompleted=hasErrored=false;};var resetAndUnsubscribe=function resetAndUnsubscribe(){var conn=connection;reset();conn===null||conn===void 0?void 0:conn.unsubscribe();};return operate(function(source,subscriber){refCount++;if(!hasErrored&&!hasCompleted){cancelReset();}var dest=subject=subject!==null&&subject!==void 0?subject:connector();subscriber.add(function(){refCount--;if(refCount===0&&!hasErrored&&!hasCompleted){resetConnection=handleReset(resetAndUnsubscribe,resetOnRefCountZero);}});dest.subscribe(subscriber);if(!connection&&refCount>0){connection=new SafeSubscriber({next:function next(value){return dest.next(value);},error:function error(err){hasErrored=true;cancelReset();resetConnection=handleReset(reset,resetOnError,err);dest.error(err);},complete:function complete(){hasCompleted=true;cancelReset();resetConnection=handleReset(reset,resetOnComplete);dest.complete();}});innerFrom(source).subscribe(connection);}})(wrapperSource);};}function handleReset(reset,on){var args=[];for(var _i=2;_i<arguments.length;_i++){args[_i-2]=arguments[_i];}if(on===true){reset();return;}if(on===false){return;}var onSubscriber=new SafeSubscriber({next:function next(){onSubscriber.unsubscribe();reset();}});return innerFrom(on.apply(void 0,__spreadArray([],__read(args)))).subscribe(onSubscriber);}","map":{"version":3,"names":["innerFrom","Subject","SafeSubscriber","operate","share","options","_a","connector","_b","resetOnError","_c","resetOnComplete","_d","resetOnRefCountZero","wrapperSource","connection","resetConnection","subject","refCount","hasCompleted","hasErrored","cancelReset","unsubscribe","undefined","reset","resetAndUnsubscribe","conn","source","subscriber","dest","add","handleReset","subscribe","next","value","error","err","complete","on","args","_i","arguments","length","onSubscriber","apply","__spreadArray","__read"],"sources":["/Users/jawaadahmar/Desktop/atlas-clothing/client/src/thistle-lion/node_modules/rxjs/src/internal/operators/share.ts"],"sourcesContent":["import { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubjectLike, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\n\nexport interface ShareConfig<T> {\n  /**\n   * The factory used to create the subject that will connect the source observable to\n   * multicast consumers.\n   */\n  connector?: () => SubjectLike<T>;\n  /**\n   * If `true`, the resulting observable will reset internal state on error from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"retried\" in the event of an error.\n   * If `false`, when an error comes from the source it will push the error into the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent retries\n   * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however\n   * {@link ReplaySubject} will also push its buffered values before pushing the error.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnError?: boolean | ((error: any) => ObservableInput<any>);\n  /**\n   * If `true`, the resulting observable will reset internal state on completion from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"repeated\" after it is done.\n   * If `false`, when the source completes, it will push the completion through the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent repeats\n   * or resubscriptions will resubscribe to that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnComplete?: boolean | (() => ObservableInput<any>);\n  /**\n   * If `true`, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the\n   * internal state will be reset and the resulting observable will return to a \"cold\" state. This means that the next\n   * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to\n   * again.\n   * If `false`, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject\n   * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnRefCountZero?: boolean | (() => ObservableInput<any>);\n}\n\nexport function share<T>(): MonoTypeOperatorFunction<T>;\n\nexport function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * The subscription to the underlying source Observable can be reset (unsubscribe and resubscribe for new subscribers),\n * if the subscriber count to the shared observable drops to 0, or if the source Observable errors or completes. It is\n * possible to use notifier factories for the resets to allow for behaviors like conditional or delayed resets. Please\n * note that resetting on error or complete of the source Observable does not behave like a transparent retry or restart\n * of the source because the error or complete will be forwarded to all subscribers and their subscription will be\n * closed. Only new subscribers after a reset on error or complete happened will cause a fresh subscription to the\n * source. To achieve transparent retries or restarts pipe the source through appropriate operators before sharing.\n *\n * ![](share.png)\n *\n * ## Example\n *\n * Generate new multicast Observable from the `source` Observable value\n *\n * ```ts\n * import { interval, tap, map, take, share } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   tap(x => console.log('Processing: ', x)),\n *   map(x => x * x),\n *   take(6),\n *   share()\n * );\n *\n * source.subscribe(x => console.log('subscription 1: ', x));\n * source.subscribe(x => console.log('subscription 2: ', x));\n *\n * // Logs:\n * // Processing: 0\n * // subscription 1: 0\n * // subscription 2: 0\n * // Processing: 1\n * // subscription 1: 1\n * // subscription 2: 1\n * // Processing: 2\n * // subscription 1: 4\n * // subscription 2: 4\n * // Processing: 3\n * // subscription 1: 9\n * // subscription 2: 9\n * // Processing: 4\n * // subscription 1: 16\n * // subscription 2: 16\n * // Processing: 5\n * // subscription 1: 25\n * // subscription 2: 25\n * ```\n *\n * ## Example with notifier factory: Delayed reset\n *\n * ```ts\n * import { interval, take, share, timer } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   take(3),\n *   share({\n *     resetOnRefCountZero: () => timer(1000)\n *   })\n * );\n *\n * const subscriptionOne = source.subscribe(x => console.log('subscription 1: ', x));\n * setTimeout(() => subscriptionOne.unsubscribe(), 1300);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 2: ', x)), 1700);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 3: ', x)), 5000);\n *\n * // Logs:\n * // subscription 1:  0\n * // (subscription 1 unsubscribes here)\n * // (subscription 2 subscribes here ~400ms later, source was not reset)\n * // subscription 2:  1\n * // subscription 2:  2\n * // (subscription 2 unsubscribes here)\n * // (subscription 3 subscribes here ~2000ms later, source did reset before)\n * // subscription 3:  0\n * // subscription 3:  1\n * // subscription 3:  2\n * ```\n *\n * @see {@link shareReplay}\n *\n * @return A function that returns an Observable that mirrors the source.\n */\nexport function share<T>(options: ShareConfig<T> = {}): MonoTypeOperatorFunction<T> {\n  const { connector = () => new Subject<T>(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\n  // It's necessary to use a wrapper here, as the _operator_ must be\n  // referentially transparent. Otherwise, it cannot be used in calls to the\n  // static `pipe` function - to create a partial pipeline.\n  //\n  // The _operator function_ - the function returned by the _operator_ - will\n  // not be referentially transparent - as it shares its source - but the\n  // _operator function_ is called when the complete pipeline is composed via a\n  // call to a source observable's `pipe` method - not when the static `pipe`\n  // function is called.\n  return (wrapperSource) => {\n    let connection: SafeSubscriber<T> | undefined;\n    let resetConnection: Subscription | undefined;\n    let subject: SubjectLike<T> | undefined;\n    let refCount = 0;\n    let hasCompleted = false;\n    let hasErrored = false;\n\n    const cancelReset = () => {\n      resetConnection?.unsubscribe();\n      resetConnection = undefined;\n    };\n    // Used to reset the internal state to a \"cold\"\n    // state, as though it had never been subscribed to.\n    const reset = () => {\n      cancelReset();\n      connection = subject = undefined;\n      hasCompleted = hasErrored = false;\n    };\n    const resetAndUnsubscribe = () => {\n      // We need to capture the connection before\n      // we reset (if we need to reset).\n      const conn = connection;\n      reset();\n      conn?.unsubscribe();\n    };\n\n    return operate<T, T>((source, subscriber) => {\n      refCount++;\n      if (!hasErrored && !hasCompleted) {\n        cancelReset();\n      }\n\n      // Create the subject if we don't have one yet. Grab a local reference to\n      // it as well, which avoids non-null assertions when using it and, if we\n      // connect to it now, then error/complete need a reference after it was\n      // reset.\n      const dest = (subject = subject ?? connector());\n\n      // Add the finalization directly to the subscriber - instead of returning it -\n      // so that the handling of the subscriber's unsubscription will be wired\n      // up _before_ the subscription to the source occurs. This is done so that\n      // the assignment to the source connection's `closed` property will be seen\n      // by synchronous firehose sources.\n      subscriber.add(() => {\n        refCount--;\n\n        // If we're resetting on refCount === 0, and it's 0, we only want to do\n        // that on \"unsubscribe\", really. Resetting on error or completion is a different\n        // configuration.\n        if (refCount === 0 && !hasErrored && !hasCompleted) {\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n        }\n      });\n\n      // The following line adds the subscription to the subscriber passed.\n      // Basically, `subscriber === dest.subscribe(subscriber)` is `true`.\n      dest.subscribe(subscriber);\n\n      if (\n        !connection &&\n        // Check this shareReplay is still activate - it can be reset to 0\n        // and be \"unsubscribed\" _before_ it actually subscribes.\n        // If we were to subscribe then, it'd leak and get stuck.\n        refCount > 0\n      ) {\n        // We need to create a subscriber here - rather than pass an observer and\n        // assign the returned subscription to connection - because it's possible\n        // for reentrant subscriptions to the shared observable to occur and in\n        // those situations we want connection to be already-assigned so that we\n        // don't create another connection to the source.\n        connection = new SafeSubscriber({\n          next: (value) => dest.next(value),\n          error: (err) => {\n            hasErrored = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnError, err);\n            dest.error(err);\n          },\n          complete: () => {\n            hasCompleted = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnComplete);\n            dest.complete();\n          },\n        });\n        innerFrom(source).subscribe(connection);\n      }\n    })(wrapperSource);\n  };\n}\n\nfunction handleReset<T extends unknown[] = never[]>(\n  reset: () => void,\n  on: boolean | ((...args: T) => ObservableInput<any>),\n  ...args: T\n): Subscription | undefined {\n  if (on === true) {\n    reset();\n    return;\n  }\n\n  if (on === false) {\n    return;\n  }\n\n  const onSubscriber = new SafeSubscriber({\n    next: () => {\n      onSubscriber.unsubscribe();\n      reset();\n    },\n  });\n\n  return innerFrom(on(...args)).subscribe(onSubscriber);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}