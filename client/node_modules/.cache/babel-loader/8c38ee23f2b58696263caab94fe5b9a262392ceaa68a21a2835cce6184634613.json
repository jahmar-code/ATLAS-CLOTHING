{"ast":null,"code":"export function createErrorClass(createImpl){var _super=function _super(instance){Error.call(instance);instance.stack=new Error().stack;};var ctorFunc=createImpl(_super);ctorFunc.prototype=Object.create(Error.prototype);ctorFunc.prototype.constructor=ctorFunc;return ctorFunc;}","map":{"version":3,"names":["createErrorClass","createImpl","_super","instance","Error","call","stack","ctorFunc","prototype","Object","create","constructor"],"sources":["/Users/jawaadahmar/Desktop/atlas-clothing/client/src/thistle-lion/node_modules/rxjs/src/internal/util/createErrorClass.ts"],"sourcesContent":["/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n"],"mappings":"AASA,MAAM,SAAU,CAAAA,gBAAgBA,CAAIC,UAAgC,EAClE,GAAM,CAAAC,MAAM,CAAG,QAAT,CAAAA,MAAMA,CAAIC,QAAa,EAC3BC,KAAK,CAACC,IAAI,CAACF,QAAQ,CAAC,CACpBA,QAAQ,CAACG,KAAK,CAAG,GAAI,CAAAF,KAAK,EAAE,CAACE,KAAK,CACpC,CAAC,CAED,GAAM,CAAAC,QAAQ,CAAGN,UAAU,CAACC,MAAM,CAAC,CACnCK,QAAQ,CAACC,SAAS,CAAGC,MAAM,CAACC,MAAM,CAACN,KAAK,CAACI,SAAS,CAAC,CACnDD,QAAQ,CAACC,SAAS,CAACG,WAAW,CAAGJ,QAAQ,CACzC,MAAO,CAAAA,QAAQ,CACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}