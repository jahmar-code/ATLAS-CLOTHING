{"ast":null,"code":"import{__values}from\"tslib\";import{Subscription}from'../Subscription';import{operate}from'../util/lift';import{createOperatorSubscriber}from'./OperatorSubscriber';import{arrRemove}from'../util/arrRemove';import{asyncScheduler}from'../scheduler/async';import{popScheduler}from'../util/args';import{executeSchedule}from'../util/executeSchedule';export function bufferTime(bufferTimeSpan){var _a,_b;var otherArgs=[];for(var _i=1;_i<arguments.length;_i++){otherArgs[_i-1]=arguments[_i];}var scheduler=(_a=popScheduler(otherArgs))!==null&&_a!==void 0?_a:asyncScheduler;var bufferCreationInterval=(_b=otherArgs[0])!==null&&_b!==void 0?_b:null;var maxBufferSize=otherArgs[1]||Infinity;return operate(function(source,subscriber){var bufferRecords=[];var restartOnEmit=false;var emit=function emit(record){var buffer=record.buffer,subs=record.subs;subs.unsubscribe();arrRemove(bufferRecords,record);subscriber.next(buffer);restartOnEmit&&startBuffer();};var startBuffer=function startBuffer(){if(bufferRecords){var subs=new Subscription();subscriber.add(subs);var buffer=[];var record_1={buffer:buffer,subs:subs};bufferRecords.push(record_1);executeSchedule(subs,scheduler,function(){return emit(record_1);},bufferTimeSpan);}};if(bufferCreationInterval!==null&&bufferCreationInterval>=0){executeSchedule(subscriber,scheduler,startBuffer,bufferCreationInterval,true);}else{restartOnEmit=true;}startBuffer();var bufferTimeSubscriber=createOperatorSubscriber(subscriber,function(value){var e_1,_a;var recordsCopy=bufferRecords.slice();try{for(var recordsCopy_1=__values(recordsCopy),recordsCopy_1_1=recordsCopy_1.next();!recordsCopy_1_1.done;recordsCopy_1_1=recordsCopy_1.next()){var record=recordsCopy_1_1.value;var buffer=record.buffer;buffer.push(value);maxBufferSize<=buffer.length&&emit(record);}}catch(e_1_1){e_1={error:e_1_1};}finally{try{if(recordsCopy_1_1&&!recordsCopy_1_1.done&&(_a=recordsCopy_1.return))_a.call(recordsCopy_1);}finally{if(e_1)throw e_1.error;}}},function(){while(bufferRecords===null||bufferRecords===void 0?void 0:bufferRecords.length){subscriber.next(bufferRecords.shift().buffer);}bufferTimeSubscriber===null||bufferTimeSubscriber===void 0?void 0:bufferTimeSubscriber.unsubscribe();subscriber.complete();subscriber.unsubscribe();},undefined,function(){return bufferRecords=null;});source.subscribe(bufferTimeSubscriber);});}","map":{"version":3,"names":["Subscription","operate","createOperatorSubscriber","arrRemove","asyncScheduler","popScheduler","executeSchedule","bufferTime","bufferTimeSpan","otherArgs","_i","arguments","length","scheduler","_a","bufferCreationInterval","_b","maxBufferSize","Infinity","source","subscriber","bufferRecords","restartOnEmit","emit","record","buffer","subs","unsubscribe","next","startBuffer","add","record_1","push","bufferTimeSubscriber","value","recordsCopy","slice","recordsCopy_1","__values","recordsCopy_1_1","done","shift","complete","undefined","subscribe"],"sources":["/Users/jawaadahmar/Desktop/atlas-clothing/client/src/thistle-lion/node_modules/rxjs/src/internal/operators/bufferTime.ts"],"sourcesContent":["import { Subscription } from '../Subscription';\nimport { OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  maxBufferSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferTime<T>(bufferTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, T[]> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const bufferCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxBufferSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active buffers, their related subscriptions, and removal functions.\n    let bufferRecords: { buffer: T[]; subs: Subscription }[] | null = [];\n    // If true, it means that every time we emit a buffer, we want to start a new buffer\n    // this is only really used for when *just* the buffer time span is passed.\n    let restartOnEmit = false;\n\n    /**\n     * Does the work of emitting the buffer from the record, ensuring that the\n     * record is removed before the emission so reentrant code (from some custom scheduling, perhaps)\n     * does not alter the buffer. Also checks to see if a new buffer needs to be started\n     * after the emit.\n     */\n    const emit = (record: { buffer: T[]; subs: Subscription }) => {\n      const { buffer, subs } = record;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    /**\n     * Called every time we start a new buffer. This does\n     * the work of scheduling a job at the requested bufferTimeSpan\n     * that will emit the buffer (if it's not unsubscribed before then).\n     */\n    const startBuffer = () => {\n      if (bufferRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const buffer: T[] = [];\n        const record = {\n          buffer,\n          subs,\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      // The user passed both a bufferTimeSpan (required), and a creation interval\n      // That means we need to start new buffers on the interval, and those buffers need\n      // to wait the required time span before emitting.\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n\n    const bufferTimeSubscriber = createOperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Copy the records, so if we need to remove one we\n        // don't mutate the array. It's hard, but not impossible to\n        // set up a buffer time that could mutate the array and\n        // cause issues here.\n        const recordsCopy = bufferRecords!.slice();\n        for (const record of recordsCopy) {\n          // Loop over all buffers and\n          const { buffer } = record;\n          buffer.push(value);\n          // If the buffer is over the max size, we need to emit it.\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      },\n      () => {\n        // The source completed, emit all of the active\n        // buffers we have before we complete.\n        while (bufferRecords?.length) {\n          subscriber.next(bufferRecords.shift()!.buffer);\n        }\n        bufferTimeSubscriber?.unsubscribe();\n        subscriber.complete();\n        subscriber.unsubscribe();\n      },\n      // Pass all errors through to consumer.\n      undefined,\n      // Clean up\n      () => (bufferRecords = null)\n    );\n\n    source.subscribe(bufferTimeSubscriber);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}