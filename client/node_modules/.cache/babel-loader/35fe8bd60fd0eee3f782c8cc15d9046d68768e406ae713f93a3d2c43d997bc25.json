{"ast":null,"code":"import{innerFrom}from'../observable/innerFrom';import{operate}from'../util/lift';import{createOperatorSubscriber}from'./OperatorSubscriber';export function switchMap(project,resultSelector){return operate(function(source,subscriber){var innerSubscriber=null;var index=0;var isComplete=false;var checkComplete=function checkComplete(){return isComplete&&!innerSubscriber&&subscriber.complete();};source.subscribe(createOperatorSubscriber(subscriber,function(value){innerSubscriber===null||innerSubscriber===void 0?void 0:innerSubscriber.unsubscribe();var innerIndex=0;var outerIndex=index++;innerFrom(project(value,outerIndex)).subscribe(innerSubscriber=createOperatorSubscriber(subscriber,function(innerValue){return subscriber.next(resultSelector?resultSelector(value,innerValue,outerIndex,innerIndex++):innerValue);},function(){innerSubscriber=null;checkComplete();}));},function(){isComplete=true;checkComplete();}));});}","map":{"version":3,"names":["innerFrom","operate","createOperatorSubscriber","switchMap","project","resultSelector","source","subscriber","innerSubscriber","index","isComplete","checkComplete","complete","subscribe","value","unsubscribe","innerIndex","outerIndex","innerValue","next"],"sources":["/Users/jawaadahmar/Desktop/atlas-clothing/client/src/thistle-lion/node_modules/rxjs/src/internal/operators/switchMap.ts"],"sourcesContent":["import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switchAll}.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n *\n * Generate new Observable according to source Observable values\n *\n * ```ts\n * import { of, switchMap } from 'rxjs';\n *\n * const switched = of(1, 2, 3).pipe(switchMap(x => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // 3\n * // 9\n * // 27\n * ```\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMap, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * only the values from the most recently projected inner Observable.\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return operate((source, subscriber) => {\n    let innerSubscriber: Subscriber<ObservedValueOf<O>> | null = null;\n    let index = 0;\n    // Whether or not the source subscription has completed\n    let isComplete = false;\n\n    // We only complete the result if the source is complete AND we don't have an active inner subscription.\n    // This is called both when the source completes and when the inners complete.\n    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Cancel the previous inner subscription if there was one\n          innerSubscriber?.unsubscribe();\n          let innerIndex = 0;\n          const outerIndex = index++;\n          // Start the next inner subscription\n          innerFrom(project(value, outerIndex)).subscribe(\n            (innerSubscriber = createOperatorSubscriber(\n              subscriber,\n              // When we get a new inner value, next it through. Note that this is\n              // handling the deprecate result selector here. This is because with this architecture\n              // it ends up being smaller than using the map operator.\n              (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue),\n              () => {\n                // The inner has completed. Null out the inner subscriber to\n                // free up memory and to signal that we have no inner subscription\n                // currently.\n                innerSubscriber = null!;\n                checkComplete();\n              }\n            ))\n          );\n        },\n        () => {\n          isComplete = true;\n          checkComplete();\n        }\n      )\n    );\n  });\n}\n"],"mappings":"AAEA,OAASA,SAAS,KAAQ,yBAAyB,CACnD,OAASC,OAAO,KAAQ,cAAc,CACtC,OAASC,wBAAwB,KAAQ,sBAAsB,CAiF/D,MAAM,SAAU,CAAAC,SAASA,CACvBC,OAAuC,CACvCC,cAA6G,EAE7G,MAAO,CAAAJ,OAAO,CAAC,SAACK,MAAM,CAAEC,UAAU,EAChC,GAAI,CAAAC,eAAe,CAA0C,IAAI,CACjE,GAAI,CAAAC,KAAK,CAAG,CAAC,CAEb,GAAI,CAAAC,UAAU,CAAG,KAAK,CAItB,GAAM,CAAAC,aAAa,CAAG,QAAhB,CAAAA,aAAaA,CAAA,CAAG,CAAM,OAAAD,UAAU,EAAI,CAACF,eAAe,EAAID,UAAU,CAACK,QAAQ,EAAE,CAAvD,CAAuD,CAEnFN,MAAM,CAACO,SAAS,CACdX,wBAAwB,CACtBK,UAAU,CACV,SAACO,KAAK,EAEJN,eAAe,SAAfA,eAAe,iBAAfA,eAAe,CAAEO,WAAW,EAAE,CAC9B,GAAI,CAAAC,UAAU,CAAG,CAAC,CAClB,GAAM,CAAAC,UAAU,CAAGR,KAAK,EAAE,CAE1BT,SAAS,CAACI,OAAO,CAACU,KAAK,CAAEG,UAAU,CAAC,CAAC,CAACJ,SAAS,CAC5CL,eAAe,CAAGN,wBAAwB,CACzCK,UAAU,CAIV,SAACW,UAAU,EAAK,OAAAX,UAAU,CAACY,IAAI,CAACd,cAAc,CAAGA,cAAc,CAACS,KAAK,CAAEI,UAAU,CAAED,UAAU,CAAED,UAAU,EAAE,CAAC,CAAGE,UAAU,CAAC,CAA1G,CAA0G,CAC1H,WAIEV,eAAe,CAAG,IAAK,CACvBG,aAAa,EAAE,CACjB,CAAC,CACD,CACH,CACH,CAAC,CACD,WACED,UAAU,CAAG,IAAI,CACjBC,aAAa,EAAE,CACjB,CAAC,CACF,CACF,CACH,CAAC,CAAC,CACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}